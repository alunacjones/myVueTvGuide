{
  "api/LSL.Scrutor.Extensions.AsyncInterceptorConfiguration.html": {
    "href": "api/LSL.Scrutor.Extensions.AsyncInterceptorConfiguration.html",
    "title": "Class AsyncInterceptorConfiguration | LSL.Scrutor.Extensions",
    "summary": "Class AsyncInterceptorConfiguration Namespace LSL.Scrutor.Extensions Assembly LSL.Scrutor.Extensions.dll Used to configure async interceptors for a service public class AsyncInterceptorConfiguration Inheritance object AsyncInterceptorConfiguration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add<TInterceptor>() Adds TInterceptor to the list of interceptors to apply public AsyncInterceptorConfiguration Add<TInterceptor>() where TInterceptor : IAsyncInterceptor Returns AsyncInterceptorConfiguration Type Parameters TInterceptor Operators implicit operator Type[](AsyncInterceptorConfiguration) Implicity converts InterceptorConfiguration to an array of Type public static implicit operator Type[](AsyncInterceptorConfiguration interceptor) Parameters interceptor AsyncInterceptorConfiguration Returns Type[]"
  },
  "api/LSL.Scrutor.Extensions.InterceptorConfiguration.html": {
    "href": "api/LSL.Scrutor.Extensions.InterceptorConfiguration.html",
    "title": "Class InterceptorConfiguration | LSL.Scrutor.Extensions",
    "summary": "Class InterceptorConfiguration Namespace LSL.Scrutor.Extensions Assembly LSL.Scrutor.Extensions.dll Used to configure interceptors for a service public class InterceptorConfiguration Inheritance object InterceptorConfiguration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add<TInterceptor>() Adds TInterceptor to the list of interceptors to apply public InterceptorConfiguration Add<TInterceptor>() where TInterceptor : IInterceptor Returns InterceptorConfiguration Type Parameters TInterceptor Operators implicit operator Type[](InterceptorConfiguration) Implicity converts InterceptorConfiguration to an array of Type public static implicit operator Type[](InterceptorConfiguration interceptor) Parameters interceptor InterceptorConfiguration Returns Type[]"
  },
  "api/LSL.Scrutor.Extensions.ProxyGeneratorContainer.html": {
    "href": "api/LSL.Scrutor.Extensions.ProxyGeneratorContainer.html",
    "title": "Class ProxyGeneratorContainer | LSL.Scrutor.Extensions",
    "summary": "Class ProxyGeneratorContainer Namespace LSL.Scrutor.Extensions Assembly LSL.Scrutor.Extensions.dll A container for the Castle.Core Castle.DynamicProxy.ProxyGenerator public static class ProxyGeneratorContainer Inheritance object ProxyGeneratorContainer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProxyGeneratorInstance Provides the global Castle.DynamicProxy.ProxyGenerator instance public static ProxyGenerator ProxyGeneratorInstance { get; } Property Value ProxyGenerator"
  },
  "api/LSL.Scrutor.Extensions.html": {
    "href": "api/LSL.Scrutor.Extensions.html",
    "title": "Namespace LSL.Scrutor.Extensions | LSL.Scrutor.Extensions",
    "summary": "Namespace LSL.Scrutor.Extensions Classes AsyncInterceptorConfiguration Used to configure async interceptors for a service InterceptorConfiguration Used to configure interceptors for a service ProxyGeneratorContainer A container for the Castle.Core Castle.DynamicProxy.ProxyGenerator"
  },
  "api/Microsoft.Extensions.DependencyInjection.AutoFactoryExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.AutoFactoryExtensions.html",
    "title": "Class AutoFactoryExtensions | LSL.Scrutor.Extensions",
    "summary": "Class AutoFactoryExtensions Namespace Microsoft.Extensions.DependencyInjection Assembly LSL.Scrutor.Extensions.dll AutoFactoryExtensions public static class AutoFactoryExtensions Inheritance object AutoFactoryExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddAutoFactory(IServiceCollection, Type, ServiceLifetime) Adds a factory implementation for factoryInterfaceType public static IServiceCollection AddAutoFactory(this IServiceCollection services, Type factoryInterfaceType, ServiceLifetime lifetime = ServiceLifetime.Singleton) Parameters services IServiceCollection The service collection to add to factoryInterfaceType Type The interface type of the factory lifetime ServiceLifetime The lifetime of the factory. Defaults to Singleton Returns IServiceCollection AddAutoFactory<TFactory>(IServiceCollection, ServiceLifetime) Adds a factory implementation for TFactory public static IServiceCollection AddAutoFactory<TFactory>(this IServiceCollection services, ServiceLifetime lifetime = ServiceLifetime.Singleton) where TFactory : class Parameters services IServiceCollection The service collection to add to lifetime ServiceLifetime The lifetime of the factory. Defaults to Singleton Returns IServiceCollection Type Parameters TFactory The interface type of the factory Examples try this"
  },
  "api/Microsoft.Extensions.DependencyInjection.InterceptedDecorators.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.InterceptedDecorators.html",
    "title": "Class InterceptedDecorators | LSL.Scrutor.Extensions",
    "summary": "Class InterceptedDecorators Namespace Microsoft.Extensions.DependencyInjection Assembly LSL.Scrutor.Extensions.dll ProxiedDecorators public static class InterceptedDecorators Inheritance object InterceptedDecorators Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddInterceptorsFromAssemblies(IServiceCollection, IEnumerable<Assembly>) Adds all Castle.DynamicProxy.IInterceptor and all Castle.DynamicProxy.IAsyncInterceptor types in the given assemblies public static IServiceCollection AddInterceptorsFromAssemblies(this IServiceCollection source, IEnumerable<Assembly> assemblies) Parameters source IServiceCollection assemblies IEnumerable<Assembly> Returns IServiceCollection AddInterceptorsFromAssemblies(IServiceCollection, params Assembly[]) Adds all Castle.DynamicProxy.IInterceptor and all Castle.DynamicProxy.IAsyncInterceptor types in the given assemblies public static IServiceCollection AddInterceptorsFromAssemblies(this IServiceCollection source, params Assembly[] assemblies) Parameters source IServiceCollection assemblies Assembly[] Returns IServiceCollection AddInterceptorsFromAssemblyOf<T>(IServiceCollection) Adds all Castle.DynamicProxy.IInterceptor and all Castle.DynamicProxy.IAsyncInterceptor types in the assembly that contains T public static IServiceCollection AddInterceptorsFromAssemblyOf<T>(this IServiceCollection source) Parameters source IServiceCollection Returns IServiceCollection Type Parameters T DecorateWithAsyncInterceptor<TToDecorate, TAsyncInterceptor>(IServiceCollection) Decorate TToDecorate with the TAsyncInterceptor public static IServiceCollection DecorateWithAsyncInterceptor<TToDecorate, TAsyncInterceptor>(this IServiceCollection source) where TToDecorate : class where TAsyncInterceptor : IAsyncInterceptor Parameters source IServiceCollection Returns IServiceCollection Type Parameters TToDecorate TAsyncInterceptor DecorateWithAsyncInterceptors<TToDecorate>(IServiceCollection, Action<AsyncInterceptorConfiguration>) Decorate TToDecorate using the provided configurator public static IServiceCollection DecorateWithAsyncInterceptors<TToDecorate>(this IServiceCollection source, Action<AsyncInterceptorConfiguration> configurator) where TToDecorate : class Parameters source IServiceCollection configurator Action<AsyncInterceptorConfiguration> Returns IServiceCollection Type Parameters TToDecorate DecorateWithInterceptor<TToDecorate, TInterceptor>(IServiceCollection) Decorate TToDecorate with TInterceptor public static IServiceCollection DecorateWithInterceptor<TToDecorate, TInterceptor>(this IServiceCollection source) where TToDecorate : class where TInterceptor : IInterceptor Parameters source IServiceCollection Returns IServiceCollection Type Parameters TToDecorate TInterceptor DecorateWithInterceptors(IServiceCollection, Type, IEnumerable<Type>) Decorates serviceTypeToDecorate with the given interceptorTypes public static IServiceCollection DecorateWithInterceptors(this IServiceCollection services, Type serviceTypeToDecorate, IEnumerable<Type> interceptorTypes) Parameters services IServiceCollection serviceTypeToDecorate Type interceptorTypes IEnumerable<Type> Returns IServiceCollection DecorateWithInterceptors(IServiceCollection, Type, params Type[]) Decorates serviceTypeToDecorate with the given interceptorTypes public static IServiceCollection DecorateWithInterceptors(this IServiceCollection services, Type serviceTypeToDecorate, params Type[] interceptorTypes) Parameters services IServiceCollection serviceTypeToDecorate Type interceptorTypes Type[] Returns IServiceCollection DecorateWithInterceptors<TToDecorate>(IServiceCollection, Action<InterceptorConfiguration>) Decorate TToDecorate using the provided configurator public static IServiceCollection DecorateWithInterceptors<TToDecorate>(this IServiceCollection source, Action<InterceptorConfiguration> configurator) where TToDecorate : class Parameters source IServiceCollection configurator Action<InterceptorConfiguration> Returns IServiceCollection Type Parameters TToDecorate DecorateWithInterceptors<TToDecorate>(IServiceCollection, IEnumerable<Type>) Decorate TToDecorate with the provided interceptorTypes public static IServiceCollection DecorateWithInterceptors<TToDecorate>(this IServiceCollection source, IEnumerable<Type> interceptorTypes) where TToDecorate : class Parameters source IServiceCollection interceptorTypes IEnumerable<Type> Returns IServiceCollection Type Parameters TToDecorate DecorateWithInterceptors<TToDecorate>(IServiceCollection, params Type[]) Decorate TToDecorate with the provided interceptorTypes public static IServiceCollection DecorateWithInterceptors<TToDecorate>(this IServiceCollection source, params Type[] interceptorTypes) where TToDecorate : class Parameters source IServiceCollection interceptorTypes Type[] Returns IServiceCollection Type Parameters TToDecorate"
  },
  "api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection | LSL.Scrutor.Extensions",
    "summary": "Namespace Microsoft.Extensions.DependencyInjection Classes AutoFactoryExtensions AutoFactoryExtensions InterceptedDecorators ProxiedDecorators"
  },
  "index.html": {
    "href": "index.html",
    "title": "LSL.Scrutor.Extensions | LSL.Scrutor.Extensions",
    "summary": "LSL.Scrutor.Extensions This package providers some extensions to Scrutor and Microsoft.Extensions.DependencyInjection.Abstractions NOTE: These extension methods use Castle.Core and therefore the interfaces and classes used on each extension method must be public AddAutoFactory If you have a factory interface then you can automatically create a proxy that will instantiate the type with this method. NOTE: The return type can be an interface as long as it is registered to a concrete type Example Assuming you have a definition for a factory interface as below: public interface IMyFactory { MyService Create(string name); } and also a class definition of: public class MyService { private readonly string _name; public MyService(string name) { _name = name; } public void MakeTheServiceDoSomething() { Console.WriteLine(name); } } Then a factory implementation can be created with the following: services.AddAutoFactory<IMyFactory>() NOTE: The returned service from an AddAutoFactory's interface can have other dependencies too as they will be automatically resolved. Any dependencies must be registered in the IServiceCollection This factory can than be injected into other services to create instances of MyService using the factory interface. Using your generated factory public class MyConsumer { private readonly _factory; public MyConsumer(IMyFactory factory) { _factory = factory; } public void DoSomething() { // Will write 'a-name' to the console as per the earlier // definition of 'MyService' _factory.Create(\"a-name\").MakeTheServiceDoSomething(); } } DecorateWithInterceptor Scrutor provides great Decorator functionality but sometimes a more Aspect Oreinted Programming paradigm is needed. Castle.Core provides great interception capabilites that this method utilises. Example Given definitions for the following in an assembly: NOTE: The following example expectes that an IConsole implementation is registered in the IServiceCollection See LSL.AbstractConsole for an implementation that can be used with an IServiceCollection via the LSL.AbstractConsole.ServiceProvider package. public interface IThingy { void DoSomething(); } public class Thingy : IThingy { private readonly IConsole _console; public Thingy(IConsole console) => _console = console; public void DoSomething() => _console.WriteLine(\"Something done\"); } public class MyInterceptor : IInterceptor { private readonly IConsole _console; public MyInterceptor(IConsole console) => _console = console; public void Intercept(IInvocation invocation) { _console.WriteLine($\"Before invoke of {invocation.Method.Name}\"); invocation.Proceed(); _console.WriteLine($\"After invoke of {invocation.Method.Name}\"); } } Then we can easily register a decorator with the provided interceptor as follows: services.AddInterceptorsFromAssemblyOf<MyInterceptor>() .AddScoped<IThingy, Thingy>() .DecorateWithInterceptor<IThingy, MyInterceptor>(); Now we can just inject an IThingy and get MyInterceptor to intercept every call on it. If using the aforementioned IConsole implemtation, then a class that consumes IThingy as shown below would get intercepted: public class MyConsumer { public MyConsumer(IThingy thing) => _thingy = thingy; public void DoSomethingElse() { // This would result in an `IConsole` // getting output of: // Before invoke of 'DoSomething' // Something done // After invoke of 'DoSomething' _thingy.DoSomething(); } }"
  },
  "other.html": {
    "href": "other.html",
    "title": "Title | LSL.Scrutor.Extensions",
    "summary": "Title will it?"
  }
}